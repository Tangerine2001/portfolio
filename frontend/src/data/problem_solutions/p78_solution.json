{
    "solutions": {
        "solution1": {
            "python": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        def dfs(curr, i):\n            if i >= len(nums):\n                res.append(curr.copy())\n                return\n\n            # Include element at i\n            curr.append(nums[i])\n            dfs(curr, i + 1)\n\n            # Don't include element at i\n            curr.pop()\n            dfs(curr, i + 1)\n\n        dfs([], 0)\n        return res\n"
        }
    },
    "components": [
        {
            "type": "problem_title",
            "text": "Leetcode 78: Subsets"
        },
        {
            "type": "problem_desc",
            "text": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order."
        },
        {
            "type": "example_case",
            "input": [
                "nums = [1,2,3]"
            ],
            "output": [
                "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
            ],
            "explanation": [
                {
                    "type": "text",
                    "text": "You can verify the output with brute force"
                }
            ]
        },
        {
            "type": "solution_title",
            "text": "Solution 1: Just Add Them"
        },
        {
            "type": "solution_desc",
            "text": "The solution to this problem is to use a depth-first search (DFS) algorithm to generate all possible subsets of the input array. The algorithm starts with an empty subset and recursively adds each element of the input array to the subset, generating all possible combinations of elements. The algorithm then backtracks and removes the last element added to the subset, generating all possible subsets that do not contain that element. The algorithm continues this process until all possible subsets have been generated.\n\nThe runtime of this algorithm is O(2^n), where n is the number of elements in the input array. This is because there are 2^n possible subsets of an array with n elements. The space complexity of the algorithm is also O(2^n), as the algorithm generates all possible subsets of the input array."
        },
        {
            "type": "solution",
            "solution_no": 1
        }
    ]
}