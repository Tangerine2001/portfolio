{
  "solution1": "func TwoSumBruteForce(nums []int, target int) []int {\n\t// Outer loop to iterate through each element in the slice 'nums' except the last one.\n\tfor i := 0; i < len(nums)-1; i++ {\n\t\t// Inner loop to iterate through each element in the slice 'nums' starting from the element after 'i'.\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\t// Check if the sum of nums[i] and nums[j] equals the target.\n\t\t\tif nums[i]+nums[j] == target {\n\t\t\t\t// If the sum equals the target, return the indices i and j.\n\t\t\t\treturn []int{i, j}\n\t\t\t}\n\t\t}\n\t}\n\t// If no such pair is found, return a default value of indices 0 and 1.\n\t// This could be a placeholder or an indicator that no solution was found.\n\treturn []int{0, 1}\n}",
  "solution2": "import \"sort\"\n\n// IndexedValue Define a struct to hold the value and the original index\ntype IndexedValue struct {\n\tValue int // The value from the nums slice\n\tIndex int // The original index of the value in the nums slice\n}\n\nfunc TwoSumTwoPointers(nums []int, target int) []int {\n\t// Create a slice of IndexedValue with the same length as nums\n\tindexedArr := make([]IndexedValue, len(nums))\n\n\t// Populate the indexedArr slice with values and their original indices from nums\n\tfor i, v := range nums {\n\t\tindexedArr[i] = IndexedValue{Value: v, Index: i}\n\t}\n\n\t// Sort the indexedArr slice based on the values in ascending order\n\tsort.Slice(indexedArr, func(i, j int) bool {\n\t\treturn indexedArr[i].Value < indexedArr[j].Value\n\t})\n\n\t// Initialize two pointers: l starts at the beginning, r starts at the end of the slice\n\tl, r := 0, len(nums)-1\n\n\t// Loop until the two pointers meet\n\tfor l < r {\n\t\t// Get the values at the two pointers\n\t\tlValue := indexedArr[l].Value\n\t\trValue := indexedArr[r].Value\n\n\t\t// Calculate the sum of the two values\n\t\tsum := lValue + rValue\n\n\t\t// Check if the sum is equal to the target\n\t\tif sum == target {\n\t\t\t// If the sum equals the target, return the original indices of the two values\n\t\t\treturn []int{indexedArr[l].Index, indexedArr[r].Index}\n\t\t} else if sum < target {\n\t\t\t// If the sum is less than the target, move the left pointer to the right\n\t\t\tl += 1\n\t\t} else if sum > target {\n\t\t\t// If the sum is greater than the target, move the right pointer to the left\n\t\t\tr -= 1\n\t\t}\n\t}\n\n\t// If no such pair is found, return a default value of indices 0 and 1.\n\t// This could be a placeholder or an indicator that no solution was found.\n\treturn []int{0, 1}\n}\n",
  "solution3": "func TwoSumHashMap(nums []int, target int) []int {\n\t// Create a map to keep track of the numbers we have seen and their indices.\n\tseen := make(map[int]int)\n\n\t// Populate the map with the value as the key and the index as the value.\n\tfor index, value := range nums {\n\t\tseen[value] = index\n\t}\n\n\t// Iterate through each element in the nums slice.\n\tfor i := 0; i < len(nums); i++ {\n\t\t// Check if the complement (target - nums[i]) exists in the map\n\t\t// and ensure it is not the same element by checking the indices.\n\t\tif j, ok := seen[target-nums[i]]; ok && i != j {\n\t\t\t// If the complement exists and is not the same element, return the indices.\n\t\t\treturn []int{i, j}\n\t\t}\n\t}\n\n\t// If no such pair is found, return a default value of indices 0 and 1.\n\t// This could be a placeholder or an indicator that no solution was found.\n\treturn []int{0, 1}\n}"
}